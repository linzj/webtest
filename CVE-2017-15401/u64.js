function s32_to_u32(s32) {
  if (s32 < 0)
    s32 += 0x100000000;
  return s32;
}

function u32_to_str(u32) {
  var s = u32.toString(16);
  if (s.length < 8)
    s = (new Array(8 - s.length + 1)).join('0') + s
  return s;
}

class u64 {
  constructor(lo, hi) {
    this.lo = s32_to_u32(lo|0);
    this.hi = s32_to_u32(hi|0);
  }
  copy() {
    return new u64(this.lo, this.hi);
  }
  add(v) {
    var lo = this.lo + v.lo;
    var hi = this.hi + v.hi;
    if (lo >= 0x100000000)
      hi++;
    return new u64(lo, hi);
  }
  sub(v) {
    return this.add(v.neg());
  }
  neg() {
    return this.not().add_u32(1);
  }
  add_u32(v) {
    return this.add(mku64(v));
  }
  sub_u32(v) {
    return this.add(mku64(-v));
  }
  shl(b) {
    var r = mku64(0);
    if (b < 32) {
      r.lo = this.lo << b;
      r.hi = (this.hi << b) | (this.lo >>> (32 - b));
    } else if (b < 64) {
      r.hi = this.lo << (b - 32);
    }
    return r;
  }
  shr(b) {
    var r = new u64(0, 0);
    if (b < 32) {
      r.lo = (this.lo >>> b) | (this.hi << (32 - b));
      r.hi = this.hi >>> b;
    } else if (b < 64) {
      r.lo = this.hi >> (b - 32);
    }
    return r;
  }
  and(v) {
    return new u64(this.lo & v.lo, this.hi & v.hi);
  }
  or(v) {
    return new u64(this.lo | v.lo, this.hi | v.hi);
  }
  not() {
    return new u64(~this.lo, ~this.hi);
  }
  bswap() {
    var r = new u64(0, 0);
    var t = this.copy();
    for (var i = 0; i < 8; i++) {
      r = r.shl(8).add_u32(t.lo & 0xff);
      t = t.shr(8);
    }
    return r;
  }
  equals(v) {
    return this.lo == v.lo && this.hi == v.hi;
  }
  is_zero() {
    return this.lo == 0 && this.hi == 0;
  }
  val() {
    return this.hi * 0x100000000 + this.lo;
  }
  str() {
    return '0x' + u32_to_str(this.hi) + u32_to_str(this.lo);
  }
}

function mku64(lo) {
  if (lo < 0)
    return new u64(-lo, 0).neg();
  return new u64(lo, 0);
}

